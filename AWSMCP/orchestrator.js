#!/usr/bin/env node

const { spawn } = require('child_process');
const path = require('path');
const readline = require('readline');
const fetch = require('node-fetch');

const PROJECT_ROOT = path.resolve(__dirname, '..');
const DASHBOARD_PATH = path.join(PROJECT_ROOT, 'dashboard');
const AGENT_PATH = path.join(PROJECT_ROOT, 'first-agent');

function runDashboard() {
  const proc = spawn('npm', ['run', 'dev'], {
    cwd: DASHBOARD_PATH,
    stdio: 'inherit',
    shell: true,
  });
  proc.on('close', code => {
    console.log(`Dashboard exited with code ${code}`);
  });
}

function runAgent() {
  const proc = spawn('python', ['cli.py', 'generate', '--help'], {
    cwd: AGENT_PATH,
    stdio: 'inherit',
    shell: true,
  });
  proc.on('close', code => {
    console.log(`First-agent exited with code ${code}`);
  });
}

function printHelp() {
  console.log(`Usage: node orchestrator.js [dashboard|agent|all|help]\n`);
  console.log('  dashboard   Start the dashboard (Next.js)');
  console.log('  agent       Run the first-agent (Python)');
  console.log('  all         Run both dashboard and agent');
  console.log('  help        Show this help message');
}

function askQuestion(query) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  return new Promise(resolve => rl.question(query, ans => {
    rl.close();
    resolve(ans);
  }));
}

async function runFirstAgentGenerate(commitOrPR) {
  return new Promise((resolve, reject) => {
    const proc = spawn('python', ['cli.py', 'generate', commitOrPR, '--no-preview'], {
      cwd: AGENT_PATH,
      shell: true,
    });
    let output = '';
    proc.stdout && proc.stdout.on('data', data => { output += data.toString(); });
    proc.stderr && proc.stderr.on('data', data => { output += data.toString(); });
    proc.on('close', code => {
      if (code === 0) {
        // Try to extract the prompt from the output (assume it's in a markdown/code block)
        const match = output.match(/Prompt:(.*)/s);
        resolve(match ? match[1].trim() : output.trim());
      } else {
        reject(new Error('first-agent failed: ' + output));
      }
    });
  });
}

async function vibeTest(cmdArgs) {
  const commitOrPR = cmdArgs[0];
  let url = null;
  let prompt = null;
  for (let i = 1; i < cmdArgs.length; ++i) {
    if (cmdArgs[i] === '--url') url = cmdArgs[++i];
    if (cmdArgs[i] === '--prompt') prompt = cmdArgs[++i];
  }
  if (!url) {
    url = await askQuestion('Enter deployment URL for this commit/PR: ');
  }
  if (!prompt) {
    console.log('Generating prompt using first-agent...');
    try {
      prompt = await runFirstAgentGenerate(commitOrPR);
      console.log('Prompt generated by first-agent:\n', prompt);
    } catch (e) {
      console.error('Failed to generate prompt:', e.message);
      prompt = await askQuestion('Enter prompt for QA test: ');
    }
  }
  // POST to testBrowserbase API
  const apiUrl = 'http://localhost:3000/qa-test';
  console.log(`\nTriggering QA test for URL: ${url}`);
  try {
    const res = await fetch(apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url, promptContent: prompt })
    });
    const data = await res.json();
    if (data.success || data.githubComment) {
      console.log('QA test triggered successfully!');
      console.log('View results in the dashboard: http://localhost:7777/test');
    } else {
      console.error('QA test failed:', data.error || data);
    }
  } catch (e) {
    console.error('Error calling testBrowserbase API:', e.message);
  }
}

const cmd = process.argv[2];

switch (cmd) {
  case 'dashboard':
    runDashboard();
    break;
  case 'agent':
    runAgent();
    break;
  case 'all':
    runDashboard();
    runAgent();
    break;
  case 'help':
  default:
    printHelp();
    break;
}

if (cmd === 'vibe-test') {
  vibeTest(process.argv.slice(3));
  return;
} 